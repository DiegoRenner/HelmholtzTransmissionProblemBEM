/**
 * \file cbessel.cpp
 *
 * \brief This file contains the implementation of Bessel functions
 * of real order and complex argument.
 *
 * If CBESSEL_EXCEPT is defined, then routines will throw exceptions.
 *
 * (c) 2023 Luka MarohniÄ‡
 */

#include "cbessel.hpp"
#include <limits>
#include <vector>
#include <numeric>
#include <cmath>

#define MAXITER 10000
//#define CBESSEL_EXCEPT 1

namespace complex_bessel {

    /* precomputed data */
    const Real D[10] = {
       -0.77822634399050712540469014052832e-11,0.11812745704870201445881285719317e-8,
       -0.61160951044814158178624971108758e-8,-0.11330272319816958823741296185618e-5,
        0.20134854780788238655689391422764e-4, 0.21524167411495097281572996305591e-3,
       -0.72189432466630995423950103404449e-2, 0.42197734555544336748208301289190e-1,
        0.42002635034095235529003934875432e-1,-0.57721566490153286060651209008240
    };
    const Real fg_coef[28] = {
        0.16666666666666666666666666666667,    0.55555555555555555555555555555555e-2,
        0.77160493827160493827160493827160e-4, 0.58454919566030677141788252899364e-6,
        0.27835675983824131972280120428268e-8, 0.90966261385046182915948105974733e-11,
        0.21658633663106234027606691898746e-13,0.83333333333333333333333333333333e-1,
        0.19841269841269841269841269841270e-2, 0.22045855379188712522045855379189e-4,
        0.14131958576403020847465291909736e-6, 0.58883160735012586864438716290567e-9,
        0.17217298460529996159192607102505e-11,0.37266879784696961383533781607154e-14,
        0.66666666666666666666666666666666e-1, 0.13888888888888888888888888888889e-2,
        0.14029180695847362514029180695847e-4, 0.83507027951472395916840361284805e-7,
        0.32747854098616625849741318150904e-9, 0.90966261385046182915948105974732e-12,
        0.18833594489657594806614514694561e-14,0.33333333333333333333333333333333,
        0.13888888888888888888888888888889e-1, 0.22045855379188712522045855379189e-3,
        0.18371546149323927101704879482657e-5, 0.94213057176020138983101946064908e-8,
        0.32712867075006992702465953494760e-10,0.81987135526333315043774319535738e-13
    };
    const Real g_coef[27] = {
        0.28218002735510577802732856336527e-2, 0.29551595693827814810411824275444e-2, 0.31007571189141127493698155423136e-2,
        0.32603029704905452472689728204689e-2, 0.34358352570203194319947068346683e-2, 0.36298018314290030475246407322153e-2,
        0.38451673228631979715111955419110e-2, 0.40855552853676180590258925703096e-2, 0.43554395320217693480267286350040e-2,
        0.46604055683625348212215275828782e-2, 0.50075137925395733265965217637280e-2, 0.54058134958992978258966706195442e-2,
        0.58670855032034623457257658591866e-2, 0.64069405257066798145061932631493e-2, 0.70464873472844527966685022425184e-2,
        0.78149449106480937308394829895925e-2, 0.87538795803476454843692547489246e-2, 0.99243701063652852104195569133095e-2,
        0.11419737767544968453057612632307e-1, 0.13389564389687457919491118658434e-1, 0.16088515817830306344627357386996e-1,
        0.19985518906371944797713031471726e-1, 0.26040916906094147125026017414173e-1, 0.36547709820363185850985355314301e-1,
        0.58496334459404825507049063909346e-1, 0.12599210498948731647672106072782,    1.2599210498948731647672106072782
    };
    const Real xi_coef[27] = {
        0.18867924528301886792452830188679e-1, 0.19607843137254901960784313725490e-1, 0.20408163265306122448979591836735e-1,
        0.21276595744680851063829787234043e-1, 0.22222222222222222222222222222222e-1, 0.23255813953488372093023255813953e-1,
        0.24390243902439024390243902439024e-1, 0.25641025641025641025641025641026e-1, 0.27027027027027027027027027027027e-1,
        0.28571428571428571428571428571428e-1, 0.30303030303030303030303030303030e-1, 0.32258064516129032258064516129032e-1,
        0.34482758620689655172413793103448e-1, 0.37037037037037037037037037037037e-1, 0.40000000000000000000000000000000e-1,
        0.43478260869565217391304347826087e-1, 0.47619047619047619047619047619047e-1, 0.52631578947368421052631578947368e-1,
        0.58823529411764705882352941176471e-1, 0.66666666666666666666666666666666e-1, 0.76923076923076923076923076923077e-1,
        0.90909090909090909090909090909091e-1, 0.11111111111111111111111111111111,    0.14285714285714285714285714285714,
        0.2,                                   0.33333333333333333333333333333333,    0.0
    };
    const Real U_C[78] = {
        1.0,                                  -0.20833333333333333333333333333333,    0.125,
        0.33420138888888888888888888888889,   -0.40104166666666666666666666666666,    0.703125e-1,
       -1.0258125964506172839506172839506,     1.8464626736111111111111111111111,    -0.8912109375,
        0.732421875e-1,                        4.6695844234262474279835390946501,    -0.11207002616222993827160493827160e2,
        8.78912353515625,                     -2.3640869140625,                       0.112152099609375,
       -0.28212072558200244877400548696844e2,  0.84636217674600734632201646090534e2, -0.91818241543240017361111111111110e2,
        0.42534998745388454861111111111110e2, -7.3687943594796316964285714285714,     0.227108001708984375,
        0.21257013003921712286096941205608e3, -0.76525246814118164229948988340191e3,  0.10599904525279998779296875e4,
       -0.69957962737613254123263888888887e3,  0.21819051174421159047929067460317e3, -0.26491430486951555524553571428571e2,
        0.5725014209747314453125,             -0.19194576623184069963100630838636e4,  0.80617221817373093845022649522270e4,
       -0.13586550006434137438550407503858e5,  0.11655393336864533247771086516203e5, -0.53056469786134031083848741319443e4,
        0.12009029132163524627685546875e4,    -0.10809091978839465550013950892857e3,  1.7277275025844573974609375,
        0.20204291330966148643451236940043e5, -0.96980598388637513488565937312207e5,  0.19254700123253153235905782021939e6,
       -0.20340017728041553427816581987713e6,  0.12220046498301745978770432648835e6, -0.41192654968897551298141479492187e5,
        0.71095143024893637214388166155132e4, -0.49391530477308801242283412388392e3,  6.0740420012734830379486083984374,
       -0.24291918790055133345853177006153e6,  0.13117636146629772006760715583323e7, -0.29980159185381067500913462030544e7,
        0.37632712976564039964021056222762e7, -0.28135632265865341107078683556188e7,  0.12683652733216247816259662310282e7,
       -0.33164517248456357783150105249313e6,  0.45218768981362726273281233651296e5, -0.24998304818112096241251988844438e4,
        0.24380529699556063860654830932616e2,  0.32844698530720378211372316410403e7, -0.19706819118432226926823389846242e8,
        0.50952602492664642206381821980497e8, -0.74105148211532657748335620964413e8,  0.66344512274729026664798798454327e8,
       -0.37567176660763351308163197964061e8,  0.13288767166421818329437411631699e8, -0.27856181280864546889594445625940e7,
        0.30818640461266239848039078427709e6, -0.13886089753717040531972253864462e5,  0.11001714026924673817120492458343e3,
       -0.49329253664509961972761831275473e8,  0.32557307418576574902022808641812e9, -0.93946235968157840254624430092036e9,
        0.15535968995705800561581210443879e10,-0.16210805521083370752481758826367e10, 0.11068428168230144682596666690962e10,
       -0.49588978427503030925463624537424e9,  0.14206290779753309518565327851791e9, -0.24474062725738728467813008156015e8,
        0.22437681779224494292307377802397e7, -0.84005433603024085288678281256681e5,  0.55133589612202058560797013342379e3
    };
    const Real lambda_coef[12] = {
        1.0,                                   0.10416666666666666666666666666667,    0.83550347222222222222222222222222e-1,
        0.12822657455632716049382716049383,    0.29184902646414046424897119341564,    0.88162726744375765241876714677641,
        3.3214082818627675447026470633764,     0.14995762986862554658672367842684e2,  0.78923013011586518138481394297045e2,
        0.47445153886826432316119486340145e3,  0.32074900908906619347043277744536e4,  0.24086549640874004869512612927478e5
    };
    const Real mu_coef[12] = {
       -1.0,                                   0.14583333333333333333333333333333,    0.98741319444444444444444444444444e-1,
        0.14331205391589506172839506172839,    0.31722720267841354809670781893004,    0.94242914795712024913730281207133,
        3.5112030408263542615427983241407,     0.15727263620368045129827117493547e2,  0.82281439097185944442246560011813e2,
        0.49235537052367052403520221673735e3,  0.33162185685479725087621015973164e4,  0.24827674245208589634728385632939e5
    };
    const Real a_coef[135] = {
       -0.16305767447865746312079440732310e-3,-0.18135869221097068720365015744785e-3,-0.20044391109497149811631779997710e-3,
       -0.22004826004542284821273001252561e-3,-0.23978401439648034204644056142302e-3,-0.25910392846703170884152708532457e-3,
       -0.27725565558293477765515932638578e-3,-0.29322647061455733150858004134460e-3,-0.30567803846632437428606654614710e-3,
       -0.31287255875806716690707735327141e-3,-0.31259471264382012432567324424727e-3,-0.30207951415545692189623948299629e-3,
       -0.27796615069490665528084461951383e-3,-0.23631487360587298676625456673139e-3,-0.17275195286917299501958874046695e-3,
       -0.82852022023213704095778729489894e-4, 0.37066305766490415156104867629216e-4, 0.18846453551445559928134299224921e-3,
        0.36805931997144315679095573742600e-3, 0.56383232975698091510844296248695e-3, 0.74936958537899064058937530949106e-3,
        0.87733523595823551072895694681526e-3, 0.87596496995118593226989815080448e-3, 0.66008814754201414296469075446947e-3,
        0.18306773598003902064368428290729e-3,-0.42997663305887191646810490788372e-3,-0.69114139728829416761374506757465e-3,
        0.53106377380288016965990945253594e-4, 0.55280437558585257692411414466105e-4, 0.57251582377759305333029628250726e-4,
        0.58919965734469849978685824584803e-4, 0.60157789453946038753089337704870e-4, 0.60802390778843649660463501857631e-4,
        0.60647852757842174231736236811172e-4, 0.59434982039310405159561161190756e-4, 0.56839620854581526598317658122447e-4,
        0.52459529495911404961643516423587e-4, 0.45800612449018875175097032083829e-4, 0.36264274585679395679094570503209e-4,
        0.23139544314828679960310229481627e-4, 0.56069048230460226731645249910139e-5,-0.17233430236696226746386149499010e-4,
       -0.46286073058811645833504325186125e-4,-0.82298287282020836506600717903698e-4,-0.12554406306069034785490836360500e-3,
       -0.17524528034084674948581332124166e-3,-0.22856408261914137420536760144879e-3,-0.27895027379132338665887799112629e-3,
       -0.31368011524757631598807939796967e-3,-0.31091625602736156801420753007171e-3,-0.23859823060300590265230469710623e-3,
       -0.63793850631886240771706039514259e-4, 0.20247195276181616738606928763729e-3, 0.37819419920177291402661228437400e-3,
       -0.10880596251059288002655623137135e-4,-0.10201141879801644092666478412559e-4,-0.93130471509356123194066867026632e-5,
       -0.81726937967865792324232957854805e-5,-0.67273929609124828701064251326590e-5,-0.49134686709848591001231157007382e-5,
       -0.26539676969793911580155569707613e-5, 0.14404004981425181705858296457703e-6, 0.35925748581935158277146073682007e-5,
        0.78262086674449666142225483781119e-5, 0.13005667479396320337364130471038e-4, 0.19321093824793925314935625392241e-4,
        0.26993971497922490105423037146330e-4, 0.36275751200534429669558338530450e-4, 0.47439429929050879906954478613466e-4,
        0.60757033496519735375509144345255e-4, 0.76449841925089825758911430916592e-4, 0.94586909303468811113319491582362e-4,
        0.11488669202982512817307087368364e-3, 0.13633917097744512017972257917339e-3, 0.15650142760859470446226638167006e-3,
        0.17022258768359256906759118358560e-3, 0.16747110669971226946798233962277e-3, 0.13019865577324269262404817295490e-3,
        0.30446550359493640984557547809681e-4,-0.15616126394515941639138744067672e-3,-0.35421197145774384077112575919506e-3,
       -0.15017941298011948227200639368501e-4,-0.16651933002139380639779740767730e-4,-0.18481621762766608450677948904027e-4,
       -0.20535275310648060449939771845813e-4,-0.22845929716472455539093305882736e-4,-0.25452272063487056593084649237650e-4,
       -0.28399679390417481098132891850017e-4,-0.31741425660902248010878044280628e-4,-0.35540053297204249773215783032345e-4,
       -0.39868872771759886358416193566252e-4,-0.44813486800888278572569826818809e-4,-0.50473104430356162801158651148118e-4,
       -0.56961156600936904805190651899499e-4,-0.64404235772101628316004065211830e-4,-0.72937434815522121128042909531065e-4,
       -0.82692304558819327395907636905815e-4,-0.93769954989119449192203265284783e-4,-0.10618431920797401996427365800136e-3,
       -0.11974497568425405128661594303757e-3,-0.13381550386749136668731254680770e-3,-0.14680975664646554927600206825790e-3,
       -0.15512192491809622298489674331520e-3,-0.15080355805304876165913644261662e-3,-0.11644493167204863969339740154889e-3,
       -0.14198627355669119743170416071155e-4, 0.23224174518292165350988880400645e-3, 0.69373554135458897363659268421173e-3,
        0.76698134535920738822981735920026e-4, 0.80349754840779115118527792686343e-4, 0.84296310571570022307310425969687e-4,
        0.88571085247871171841465714321604e-4, 0.93212051724950325556340576094768e-4, 0.98262607836936344827055283763022e-4,
        0.10377241042299282299872357661726e-3, 0.10979829837271336857688565720615e-3, 0.11640527147473790200435574891628e-3,
        0.12366744559825326113590685697667e-3, 0.13166881654592280577658878987589e-3, 0.14050349739126979402492618250250e-3,
        0.15027477416090813375156189912292e-3, 0.16109170592901575165122291528870e-3, 0.17306077591787649317198781772621e-3,
        0.18626763663754517240298521442132e-3, 0.20073885876275235483926619901228e-3, 0.21636248571236508187456112118019e-3,
        0.23272104008323209792086856602634e-3, 0.24873043734465560936669729402824e-3, 0.26182429706150094464910024307627e-3,
        0.26599558934625477989234975282983e-3, 0.24669137274179290986013675089305e-3, 0.16592768783244973721164197354674e-3,
       -0.88489288489288489288489288489289e-4,-0.92207792207792207792207792207792e-3,-0.44444444444444444444444444444444e-2
    };
    const Real b_coef[162] = {
       -0.29164736331209081312564210294074e-3,-0.29655733423934810879622374237259e-3,-0.29743596217631660869367680903513e-3,
       -0.29308156319286116237511946609955e-3,-0.28205046986759867560740874825563e-3,-0.26262881146466885273433555202760e-3,
       -0.23281145037693741085149902105840e-3,-0.19029618798961406510617601585087e-3,-0.13250618677298261547638731412910e-3,
       -0.56660746163525207952422550452146e-4, 0.40074955527061428982835687182009e-4, 0.16031569459472150302855817950408e-3,
        0.30599192635878950067137210273048e-3, 0.47760387285658225730723702803648e-3, 0.67307320816566561871092726136189e-3,
        0.88604744041979162741073657371436e-3, 0.11035159737564269365727794817032e-2, 0.13026826128565718105351973603480e-2,
        0.14473233983061758988938179940682e-2, 0.14845749525944917918749472005490e-2, 0.13446744970154036199777513747912e-2,
        0.94926611717688106192685270229217e-3, 0.23907947525692728428863607470604e-3,-0.76220459635400983194962682139792e-3,
       -0.18342266354985679819552836890436e-2,-0.24340296293804253831049911736060e-2,-0.18018219196388569702524280320237e-2,
        0.24892338100459515560526581872202e-4, 0.20822362948246684657072244654427e-4, 0.15647778542887261955332128608593e-4,
        0.91642647412277884783442663217152e-5, 0.11369868667510028924115784585557e-5,-0.87010609684976705736826150188841e-5,
       -0.20648976103555175688209716834308e-4,-0.35034775051190052035399067932306e-4,-0.52207002889563380288638039297622e-4,
       -0.72517832771442533423559617854044e-4,-0.96292614771764418897765393843711e-4,-0.12377824076187362998730055939550e-3,
       -0.15505891859909386975702662600112e-3,-0.18992261185456235570251960860327e-3,-0.22765421412281952702942643463012e-3,
       -0.26672272304761282054104716516121e-3,-0.30432112478903980872943496466563e-3,-0.33571563577504875679729258374587e-3,
       -0.35338247091603771209147500853652e-3,-0.34599812683265634750756435450956e-3,-0.29760364659455453485814225074593e-3,
       -0.18790600363697155771061250410365e-3, 0.38473767287936609521649115189250e-5, 0.28599815419430414707463189182072e-3,
        0.62261486257313506617210360556181e-3, 0.87279080514619397591397616938255e-3, 0.73646581057257844419684316936484e-3,
        0.14554742826152400369612683952719e-4, 0.17009198463641262268177573311834e-4, 0.19789305666402163624023792707490e-4,
        0.22936363369099815190267234085966e-4, 0.26495611995051603864523941960132e-4, 0.30515799503434665897155579761281e-4,
        0.35048173003132808110125259917052e-4, 0.40144551389148680793708202648792e-4, 0.45853948516536064567575256645502e-4,
        0.52216930882697556726831460453086e-4, 0.59256454732319470361975109244770e-4, 0.66963252197573087228394143200235e-4,
        0.75272799134913406213966701410822e-4, 0.84029313301608997792791428560670e-4, 0.92929839659336389557003160201353e-4,
        0.10143795159766197259744643803268e-3, 0.10865163484877426783725834040100e-3, 0.11310364210848138896645320450327e-3,
        0.11246677526220415776689563795901e-3, 0.10313823670827219976057867990913e-3, 0.79709268407567492367714140908216e-4,
        0.34457129429496750303162142309969e-4,-0.42577810128543520436520347161882e-4,-0.16110501611996228189965892548228e-3,
       -0.32039022806703760345411634902401e-3,-0.47786456714732148726088405941268e-3,-0.47461779655995980754441833052401e-3,
       -0.19820063888529492723804307743487e-4,-0.21147965676891297111202789169595e-4,-0.22582350951834603251449233409648e-4,
       -0.24130835676128020048061636712543e-4,-0.25800617466688371345624466839686e-4,-0.27597891482833575859843395280853e-4,
       -0.29526956175080731515819620104259e-4,-0.31588856077210962111736489489196e-4,-0.33779330612336741747859414100601e-4,
       -0.36085716753541050065863558493230e-4,-0.38482263860322127360238695087209e-4,-0.40923019315775036382717157737122e-4,
       -0.43330964451126603594760934484892e-4,-0.45581305813862845170501667494642e-4,-0.47475562089008663848135925928288e-4,
       -0.48701003118673506908553802132192e-4,-0.48766544741378735197688695324695e-4,-0.46900488937914102934457810642110e-4,
       -0.41886186169669336451328627892555e-4,-0.31797241335042713537516852511660e-4,-0.13574499634326913612610395663071e-4,
        0.17625868306999139680704259467086e-4, 0.69327110565704359773882466147305e-4, 0.15246815619844660150881198146978e-3,
        0.27952065399202058881025943337723e-3, 0.44793258155238464640564614485062e-3, 0.55221307672129279005986982501080e-3,
        0.19591345014117924393561322125875e-4, 0.20116524199708166564270229271571e-4, 0.20638874978217073674111266439938e-4,
        0.21150764925622084338363602077484e-4, 0.21641842744810390520666189825875e-4, 0.22098101536199142935315249568751e-4,
        0.22500588110529241837816367896144e-4, 0.22823607372034872158766487495375e-4, 0.23032197608090914387998647501280e-4,
        0.23078538981117781675851116621588e-4, 0.22896778381471262867210587803497e-4, 0.22395465923245651411764282492509e-4,
        0.21446326379082263871554093590305e-4, 0.19867297884213378041594479893443e-4, 0.17396412547292626068259847326273e-4,
        0.13650700926214739094591893951242e-4, 0.80599616541427357065762654936331e-5,-0.24289260857573038860698388336231e-6,
       -0.12608973598023004671772761542060e-4,-0.31203892907609834030874055838930e-4,-0.59614195304645789476286284303015e-4,
       -0.10400855046081643397831523069418e-3,-0.17546399697078282820531686814719e-3,-0.29482213851274602513185100549750e-3,
       -0.50291654957203461354020960645354e-3,-0.87820470954638932839154179063920e-3,-0.14928295321342917205007340333366e-2,
        0.70990630063415348115870558051045e-4, 0.75900226964621933905416032514839e-4, 0.81346626216280146664971179182542e-4,
        0.87413054575383443683303226618903e-4, 0.94199822420423750872419384517656e-4, 0.10182877074056725765729253072988e-3,
        0.11044914450459939247401564721758e-3, 0.12024544494930288371565371288594e-3, 0.13144806811996537900758522870666e-3,
        0.14434793019733398621012664758494e-3, 0.15931689966182108118588356273978e-3, 0.17683685501971800374456069461436e-3,
        0.19754183803306252402068932315418e-3, 0.22228058079888332665663421006211e-3, 0.25221161554957328357875228204320e-3,
        0.28895214849575151669235935385144e-3, 0.33481888931829766411195842563706e-3, 0.39323283546291663799066153634529e-3,
        0.46943100760648153296533950525080e-3, 0.57178728178970487168319645188412e-3, 0.71443042172728735736186199506993e-3,
        0.92287887657293831079181693201455e-3, 0.12475311058919920157895009989263e-2, 0.18009660676105394060665593609959e-2,
        0.28850140223113277910192074676657e-2, 0.55996491106438807322987138101255e-2, 0.17998872141355330925245865818261e-1
    };

    /* some constants */
    const Real eps      =   numeric_limits<Real>::epsilon();
#ifndef CBESSEL_EXCEPT
    const Real infty    =   numeric_limits<Real>::infinity();
#endif
    const Real airy_C1  =   0.35502805388781723926006318600418;
    const Real airy_C2  =   0.25881940379280679840518356018921;
    const Real f13      =   1/3.0;
    const Real f23      =   2/3.0;
    const Real f32      =   3/2.0;
    const Real f43      =   4/3.0;
    const Real f16      =   1/6.0;
    const Real sqrt_1_3 =   sqrt(f13);
    const Cplx i        =   Cplx(0.0,1.0);

    /* exceptions */
#ifdef CBESSEL_EXCEPT
    const overflow_error of_err("Overflow");
    const underflow_error uf_err("Underflow");
    const invalid_argument ia_err("Undefined");
    const length_error cvg_err("Failed to converge");
#endif

    /* utilities */
    Real sign1(Real x) {
        return x>=0.0?1.0:-1.0;
    }
    bool undef(const Cplx &z) {
        return isnan(real(z)) || isnan(imag(z));
    }
    bool zero(Real x) {
        int c=fpclassify(x);
        return c==FP_ZERO || c==FP_SUBNORMAL;
    }
    bool inf(const Cplx &z) {
        return isinf(real(z)) || isinf(imag(z));
    }
    bool zero(const Cplx &z) {
        return zero(real(z)) && zero(imag(z));
    }
    Real v_L(Real eps) {
        return -8.0-6.0*log10(eps);
    }

    /* Olver expansion routines for large order */
    olver_data::olver_data() {
        is_valid=false;
        S1=S2=0.0;
    }
    Cplx U(int k,const Cplx &t2) {
        size_t k0=(k*(k+1))/2;
        return accumulate(U_C+k0,U_C+k0+k+1,Cplx(0,0),[&t2](Cplx &a,Real c) { return a*t2+c; });
    }
    void olver(Real v,const Cplx &z,Real s,OlverData &data) {
        Cplx zv=-s*z*i/v,w2=1.0-zv*zv,w=sqrt(w2);
        Real iv2=1.0/(v*v),v13=pow(v,-f13);
        int j,k;
        if (abs(w2)>0.25) {
            data.xi=log((1.0+w)/zv)-w;
            data.phi=pow(12.0*data.xi,f16)/sqrt(w)*v13;
            Cplx t=1.0/w,t2=1.0/w2,tk,ix=f23/data.xi,A,B;
            for (k=6;k-->0;) {
                A=0.0,B=0.0,tk=w;
                for (j=2*(k+1);j-->0;) {
                    if (j<=2*k)
                        A=A*ix-mu_coef[j]*U(2*k-j,t2)*tk;
                    B=B*ix-lambda_coef[j]*U(2*k-j+1,t2)*(tk*=t);
                }
                data.S1=data.S1*iv2+A;
                data.S2=data.S2*iv2+B;
            }
            data.S2*=pow(ix,f13);
            Real u=sign1(imag(data.xi));
            if (s*u<0.0) {
                data.S2*=exp(u*M_PI*f23*i);
                data.phi*=exp(-u*M_PI*f13*i);
            }
        } else {
            Cplx a0(0.0);
            data.xi=w*accumulate(xi_coef,xi_coef+27,a0,[&w2](Cplx &a,Real c) { return a*w2+c; });
            data.phi=v13*accumulate(g_coef,g_coef+27,a0,[&w2](Cplx &a,Real c) { return a*w2+c; });
            const Real *ac=a_coef,*bc=b_coef;
            for (k=0;k<6;++k,ac+=27,bc+=27) {
                data.S1=data.S1*iv2+(k==5?1.0:accumulate(ac,ac+27,a0,[&w2](Cplx &a,Real c) { return a*w2+c; }));
                data.S2=data.S2*iv2+accumulate(bc,bc+27,a0,[&w2](Cplx &a,Real c) { return a*w2+c; });
            }
        }
        data.is_valid=true;
    }
    int airy_olver(Real v,const Cplx &xi,Real s,Cplx &ai,Cplx &aip,bool &corr,bool rot,bool scaled);

    /* workhorse routines */
    Cplx K_in(Real v,const Cplx &z,bool scaled,Cplx *K_val_1=nullptr,OlverData *data=nullptr);
    Cplx K0_in(const Cplx &z,bool scaled);
    Cplx K1_in(const Cplx &z,bool scaled);
    Cplx I_in(Real v,const Cplx &z,bool scaled,Cplx *K_val=nullptr,OlverData *data=nullptr) {
        if (undef(z) || (inf(z) && isinf(v)))
#ifdef CBESSEL_EXCEPT
            throw ia_err;
#else
            return NAN;
#endif
        if (isinf(v))
#ifdef CBESSEL_EXCEPT
            throw uf_err;
#else
            return 0.0;
#endif
        if (inf(z))
#ifdef CBESSEL_EXCEPT
            throw of_err;
#else
            return infty;
#endif
        if (zero(z))
            return zero(v)?1.0:0.0;
        if (v<0.0 && v==round(v))
            return I_in(-v,z,scaled);
        if (real(z)<0.0)
            return exp(v*M_PI*sign1(imag(z))*i)*I_in(v,-z,scaled);
        if (v<0.0) {
            OlverData data;
            Cplx Kv=NAN,Iv;
#ifdef CBESSEL_EXCEPT
            try {
#endif
                Iv=I_in(-v,z,scaled,&Kv,&data);
#ifdef CBESSEL_EXCEPT
            } catch (const underflow_error &e) { Iv=0.0; }
#endif
            if (scaled || undef(Kv))
#ifdef CBESSEL_EXCEPT
            try {
#endif
                Kv=K_in(-v,z,false,nullptr,&data)*(scaled?exp(-real(z)):1.0);
#ifdef CBESSEL_EXCEPT
            } catch (const underflow_error &e) { Kv=0.0; }
#endif
            return Iv-M_2_PI*sin(M_PI*v)*Kv;
        }
        if (zero(abs(2.0*arg(z)-M_PI)))
            return cyl_bessel_j(v,imag(z))*exp(i*v*M_PI_2);
        /* Basic case: Re(z)>=0, v>=0 */
        Cplx z2=2.0/z;
        Real R=abs(z),vL=v_L(eps);
        int maxiter=MAXITER,j;
        if (R<=2.0*sqrt(v+1.0)) {
            Real tg=tgamma(1.0+v),scale=scaled?exp(-real(z)):1.0;
            Cplx A=1.0,z24=0.25*z*z,a=isinf(tg)?NAN:scale*pow(z2,-v)/tg,res=1.0;
            if (zero(a))
#ifdef CBESSEL_EXCEPT
                throw uf_err;
#else
                return 0.0;
#endif
            Real b=1.0,eps2=eps*0.5,R24=0.25*R*R,k=0.0;
            z24/=R24;
            while (b>k*eps2 && k++<maxiter)
                res+=(A*=z24)*(b*=R24/(k*(k+v)));
#ifdef CBESSEL_EXCEPT
            if (k>maxiter) throw cvg_err;
#endif
            if (undef(a)) {
                Real vfl=floor(v),vf=v-vfl;
                int vi=int(vfl);
                res*=scale*pow(z2,vf)/(vf*tgamma(vf));
                for (j=1;j<=vi;++j) res*=z2/(vf+j);
#ifdef CBESSEL_EXCEPT
                if (zero(res)) throw uf_err;
#endif
                return res;
            }
            return res*a;
        }
        if (v>vL) {
            Real theta=arg(z),s=sign1(theta);
            if (3.0*abs(theta)<M_PI) {
                Real iv=1.0/v;
                Cplx zv=z*iv,zv2=zv*zv,it2=1.0+zv2,it=sqrt(it2),zet=it-log((1.0+it)/zv);
                Cplx t=1.0/it,t2=1.0/it2,tk=pow(t2,6),res=0.0;
                for (int k=12;k-->1;)
                    res=res*iv+U(k,t2)*(tk*=it);
                Cplx ret=sqrt(t*M_1_PI*iv*0.5)*exp((scaled?-real(z):0.0)+v*zet)*(iv*res+1.0);
#ifdef CBESSEL_EXCEPT
                if (inf(ret)) throw of_err;
                if (zero(ret)) throw uf_err;
#endif
                return ret;
            }
            Cplx ai,aip,C,ret;
            OlverData od;
            if (data==nullptr) data=&od;
            olver(v,z,s,*data);
            bool corr;
            int e=airy_olver(v,data->xi,s,ai,aip,corr,false,scaled);
            C=exp(s*M_PI*v*i*0.5-(scaled?real(z)+(corr?v*data->xi:0.0):0.0))*data->phi;
#ifdef CBESSEL_EXCEPT
            if (e==1) { if (zero(C)) throw ia_err; throw of_err; }
            if (e==2) { if (inf(C)) throw ia_err; throw uf_err; }
            if (inf(C)) throw of_err;
            if (zero(C)) throw uf_err;
#endif
            ret=C*(ai*data->S1+aip*pow(v,-f43)*data->S2);
#ifdef CBESSEL_EXCEPT
            if (inf(ret)) throw of_err;
            if (zero(ret)) throw uf_err;
#endif
            return ret;
        }
        Real RL=1.2*(1.0-round(log10(eps)))+2.4,v2=v*v;
        if (R>RL && 2.0*R>v2) {
            Cplx f2=exp(sign1(imag(z))*(v+.5)*M_PI*i-z-(scaled?real(z):0.0));
            Cplx f1=exp(scaled?i*imag(z):z);
            if (inf(f1))
#ifdef CBESSEL_EXCEPT
                throw of_err;
#else
                return infty;
#endif
            Cplx sn=0.0,sp=1.0,a=1.0,z8=0.0625*z2;
            Real f=4.0*v2-1.0,z8a=0.125/R,b=1.0;
            int jmax=2+2*(int)floor(RL);
            for (j=1;j<jmax && b>eps;++j) {
                if (j>1) {
                    f=((f-8)*(j-1))/j;
                    b*=abs(f)*z8a;
                }
                a*=f*z8;
                if (j%2) sn+=a; else sp+=a;
            }
            Cplx ret=((sp-sn)*f1+(sp+sn)*f2)/sqrt(2.0*M_PI*z);
#ifdef CBESSEL_EXCEPT
            if (inf(ret)) throw of_err;
#endif
            return ret;
        }
        if (R>vL && 2.0*R<=v2) {
            v2=v,j=0;
            while (v2<=vL) ++j,++v2;
            Cplx i1=I_in(v2,z,scaled);
            if (inf(i1))
#ifdef CBESSEL_EXCEPT
                throw of_err;
#else
                return infty;
#endif
            Cplx i0=I_in(v2+1.0,z,scaled);
            for (;j-->0;v2--) {
                i0+=v2*z2*i1,swap(i0,i1);
#ifdef CBESSEL_EXCEPT
                if (inf(i1)) throw of_err;
#endif
            }
            return i1;
        }
        /* Miller algorithm -- Recurrence + Wronskian
         * (neither I nor K can overflow/underflow here) */
        int Ri=(int)floor(R),vi=(int)floor(v),nu=max(Ri,vi),k=nu+1;
        Cplx p0=1.0,p1=-(nu+1.0)*z2;
        Real T1=abs(p1)/eps,vf=v-floor(v);
        while (norm(p1)<=T1 && k++<maxiter)
            p0-=Real(k)*z2*p1,swap(p0,p1);
#ifdef CBESSEL_EXCEPT
        if (k>maxiter) throw cvg_err;
#endif
        Real k1R=(k+1.0)/R,betaN1=k1R+sqrt(k1R*k1R-1.0);
        Real rhoN1=min(betaN1,abs(p0/p1));
        T1*=rhoN1/(rhoN1*rhoN1-1.0);
        while (norm(p1)<T1 && k++<maxiter)
            p0-=Real(k)*z2*p1,swap(p0,p1);
#ifdef CBESSEL_EXCEPT
        if (k>maxiter) throw cvg_err;
#endif
        int M=k;
        bool with_y=R<=RL;
        if (with_y) {
            Real nu3R=(nu+3.0)/R,beta0=nu3R+sqrt(nu3R*nu3R-1.0),beta02=beta0*beta0;
            Real bnd=(2.0*beta02)/(eps*(beta02-1.0)*(beta0-1.0));
            while (abs(p1)<=(k+1)*(k+1)*bnd && k++<maxiter)
                p0-=Real(k)*z2*p1,swap(p0,p1);
#ifdef CBESSEL_EXCEPT
            if (k>maxiter) throw cvg_err;
#endif
            M=R>v?k:max(M+vi,k+Ri);
        }
        Cplx y0=0.0,y1=eps,yt;
        vector<Cplx> y;
        vector<Cplx>::iterator ybeg,it,jt;
        int jmax=int(M+(R>v?Ri-vi:0));
        if (with_y) {
            jmax+=vi;
            y.resize(jmax+1);
            ybeg=it=y.begin();
            *it=y1;
        }
        Real vfnuM=vf+nu+M,vf2=2.0*vf,scl;
        for (j=0;j<jmax;) {
            yt=y0+(vfnuM-j)*z2*y1;
            if (inf(yt)) {
                scl=1.0/max(abs(real(y1)),abs(imag(y1)));
                y1*=scl,y0*=scl;
                if (with_y) for (jt=ybeg;jt<=it;++jt) *jt*=scl;
                continue;
            }
            y0=yt; ++j;
            if (with_y) *(++it)=y0;
            swap(y0,y1);
        }
        if (with_y) {
            Real lambda=2.0; j=1;
            Cplx ip=accumulate(next(y.crbegin()),y.crend(),*it,[&](const Cplx &a,const Cplx &yk) {
                Cplx res=a+yk*lambda*(1.0+vf/j);
                lambda*=1.0+vf2/j++;
                return res;
            });
            return y[jmax-vi]*(scaled?exp(i*imag(z)):exp(z))*pow(z2,-vf)/(ip*tgamma(1.0+vf));
        }
        Cplx Kv_1=NAN,k1,k2,r=y0/y1,scale=scaled?exp(i*imag(z)):1.0;
        k1=K_in(v,z,scaled,&Kv_1);
        if (K_val!=nullptr) *K_val=k1;
        if (undef(Kv_1)) {
            k2=K_in(v+1.0,z,scaled);
            return scale/(z*(k2+r*k1));
        }
        return scale/(2.0*v*k1+z*(Kv_1+r*k1));
    }
    Cplx I0_in(const Cplx &z,bool scaled,Cplx *K_val=nullptr) {
        if (undef(z))
#ifdef CBESSEL_EXCEPT
            throw ia_err;
#else
            return NAN;
#endif
        if (inf(z))
#ifdef CBESSEL_EXCEPT
            throw of_err;
#else
            return infty;
#endif
        if (zero(z))
            return 1.0;
        if (real(z)<0.0)
            return I0_in(-z,scaled);
        if (zero(abs(2.0*arg(z)-M_PI)))
            return cyl_bessel_j(0.,imag(z));
        /* Basic case: Re(z)>=0, v>=0 */
        Cplx z2=2.0/z;
        Real R=abs(z);
        int maxiter=MAXITER,j;
        if (R<=2.0) {
            Cplx A=1.0,z24=0.25*z*z,res=1.0;
            Real b=1.0,eps2=eps*0.5,R24=0.25*R*R,k=0.0;
            z24/=R24;
            while (b>k*eps2 && k++<maxiter)
                res+=(A*=z24)*(b*=R24/(k*k));
#ifdef CBESSEL_EXCEPT
            if (k>maxiter) throw cvg_err;
#endif
            return scaled?res*exp(-real(z)):res;
        }
        Real RL=1.2*(1.0-round(log10(eps)))+2.4;
        if (R>RL) {
            Cplx f2=exp(sign1(imag(z))*.5*M_PI*i-z-(scaled?real(z):0.0));
            Cplx f1=exp(scaled?i*imag(z):z);
            if (inf(f1))
#ifdef CBESSEL_EXCEPT
                throw of_err;
#else
                return infty;
#endif
            Cplx sn=0.0,sp=1.0,a=1.0,z8=0.0625*z2;
            Real f=-1.0,z8a=0.125/R,b=1.0;
            int jmax=2+2*(int)floor(RL);
            for (j=1;j<jmax && b>eps;++j) {
                if (j>1) {
                    f=((f-8)*(j-1))/j;
                    b*=abs(f)*z8a;
                }
                a*=f*z8;
                if (j%2) sn+=a; else sp+=a;
            }
            Cplx ret=((sp-sn)*f1+(sp+sn)*f2)/sqrt(2.0*M_PI*z);
#ifdef CBESSEL_EXCEPT
            if (inf(ret)) throw of_err;
#endif
            return ret;
        }
        /* Miller algorithm -- Recurrence + Wronskian
         * (neither I nor K can overflow/underflow here) */
        int Ri=(int)floor(R),nu=Ri,k=nu+1;
        Cplx p0=1.0,p1=-(nu+1.0)*z2;
        Real T1=abs(p1)/eps;
        while (norm(p1)<=T1 && k++<maxiter)
            p0-=Real(k)*z2*p1,swap(p0,p1);
#ifdef CBESSEL_EXCEPT
        if (k>maxiter) throw cvg_err;
#endif
        Real k1R=(k+1.0)/R,betaN1=k1R+sqrt(k1R*k1R-1.0);
        Real rhoN1=min(betaN1,abs(p0/p1));
        T1*=rhoN1/(rhoN1*rhoN1-1.0);
        while (norm(p1)<T1 && k++<maxiter)
            p0-=Real(k)*z2*p1,swap(p0,p1);
#ifdef CBESSEL_EXCEPT
        if (k>maxiter) throw cvg_err;
#endif
        int M=k;
        bool with_y=R<=RL;
        if (with_y) {
            Real nu3R=(nu+3.0)/R,beta0=nu3R+sqrt(nu3R*nu3R-1.0),beta02=beta0*beta0;
            Real bnd=(2.0*beta02)/(eps*(beta02-1.0)*(beta0-1.0));
            while (abs(p1)<=(k+1)*(k+1)*bnd && k++<maxiter)
                p0-=Real(k)*z2*p1,swap(p0,p1);
#ifdef CBESSEL_EXCEPT
            if (k>maxiter) throw cvg_err;
#endif
            M=k;
        }
        Cplx y0=0.0,y1=eps,yt,sum=0.0;
        int jmax=int(M+Ri);
        Real vfnuM=nu+M,scl;
        for (j=0;j<jmax;) {
            yt=y0+(vfnuM-j)*z2*y1;
            if (inf(yt)) {
                scl=1.0/max(abs(real(y1)),abs(imag(y1)));
                y1*=scl,y0*=scl;
                if (with_y) sum*=scl;
                continue;
            }
            y0=yt; ++j;
            if (j==jmax) sum*=2.0;
            if (with_y) sum+=y0;
            swap(y0,y1);
        }
        if (with_y)
            return y1*(scaled?exp(i*imag(z)):exp(z))/sum;
        Cplx k1,k2,r=y0/y1,scale=scaled?exp(i*imag(z)):1.0;
        k1=K0_in(z,scaled);
        k2=K1_in(z,scaled);
        if (K_val!=nullptr) *K_val=k1;
        return scale/(z*(k2+r*k1));
    }
    Cplx I1_in(const Cplx &z,bool scaled,Cplx *K_val=nullptr) {
        if (undef(z))
#ifdef CBESSEL_EXCEPT
            throw ia_err;
#else
            return NAN;
#endif
        if (inf(z))
#ifdef CBESSEL_EXCEPT
            throw of_err;
#else
            return infty;
#endif
        if (zero(z))
            return 0.0;
        if (real(z)<0.0)
            return -I1_in(-z,scaled);
        if (zero(abs(2.0*arg(z)-M_PI)))
            return cyl_bessel_j(1.0,imag(z))*i;
        /* Basic case: Re(z)>=0, v>=0 */
        Cplx z2=2.0/z;
        Real R=abs(z);
        int maxiter=MAXITER,j;
        if (R<=2.0*M_SQRT2) {
            Cplx A=1.0,z24=0.25*z*z,res=1.0;
            Real b=1.0,eps2=eps*0.5,R24=0.25*R*R,k=0.0;
            z24/=R24;
            while (b>k*eps2 && k++<maxiter)
                res+=(A*=z24)*(b*=R24/(k*(k+1)));
#ifdef CBESSEL_EXCEPT
            if (k>maxiter) throw cvg_err;
#endif
            return res*(scaled?exp(-real(z)):1.0)*z*0.5;
        }
        Real RL=1.2*(1.0-round(log10(eps)))+2.4;
        if (R>RL) {
            Cplx f2=exp(sign1(imag(z))*1.5*M_PI*i-z-(scaled?real(z):0.0));
            Cplx f1=exp(scaled?i*imag(z):z);
            if (inf(f1))
#ifdef CBESSEL_EXCEPT
                throw of_err;
#else
                return infty;
#endif
            Cplx sn=0.0,sp=1.0,a=1.0,z8=0.0625*z2;
            Real f=3.0,z8a=0.125/R,b=1.0;
            int jmax=2+2*(int)floor(RL);
            for (j=1;j<jmax && b>eps;++j) {
                if (j>1) {
                    f=((f-8)*(j-1))/j;
                    b*=abs(f)*z8a;
                }
                a*=f*z8;
                if (j%2) sn+=a; else sp+=a;
            }
            Cplx ret=((sp-sn)*f1+(sp+sn)*f2)/sqrt(2.0*M_PI*z);
#ifdef CBESSEL_EXCEPT
            if (inf(ret)) throw of_err;
#endif
            return ret;
        }
        /* Miller algorithm -- Recurrence + Wronskian
         * (neither I nor K can overflow/underflow here) */
        int Ri=(int)floor(R),nu=max(Ri,1),k=nu+1;
        Cplx p0=1.0,p1=-(nu+1.0)*z2;
        Real T1=abs(p1)/eps;
        while (norm(p1)<=T1 && k++<maxiter)
            p0-=Real(k)*z2*p1,swap(p0,p1);
#ifdef CBESSEL_EXCEPT
        if (k>maxiter) throw cvg_err;
#endif
        Real k1R=(k+1.0)/R,betaN1=k1R+sqrt(k1R*k1R-1.0);
        Real rhoN1=min(betaN1,abs(p0/p1));
        T1*=rhoN1/(rhoN1*rhoN1-1.0);
        while (norm(p1)<T1 && k++<maxiter)
            p0-=Real(k)*z2*p1,swap(p0,p1);
#ifdef CBESSEL_EXCEPT
        if (k>maxiter) throw cvg_err;
#endif
        int M=k;
        bool with_y=R<=RL;
        if (with_y) {
            Real nu3R=(nu+3.0)/R,beta0=nu3R+sqrt(nu3R*nu3R-1.0),beta02=beta0*beta0;
            Real bnd=(2.0*beta02)/(eps*(beta02-1.0)*(beta0-1.0));
            while (k++<maxiter && abs(p1)<=k*k*bnd)
                p0-=Real(k)*z2*p1,swap(p0,p1);
#ifdef CBESSEL_EXCEPT
            if (k>maxiter) throw cvg_err;
#endif
            M=R>1.0?k:max(M+1,k+Ri);
        }
        Cplx y0=0.0,y1=eps,yt,sum=0.0;
        int jmax=int(M+(R>1.0?Ri-1:0))+(with_y?1:0);
        Real vfnuM=nu+M,scl;
        for (j=0;j<jmax;) {
            yt=y0+(vfnuM-j)*z2*y1;
            if (inf(yt)) {
                scl=1.0/max(abs(real(y1)),abs(imag(y1)));
                y1*=scl,y0*=scl;
                if (with_y) sum*=scl;
                continue;
            }
            y0=yt; ++j;
            if (with_y) {
                if (j==jmax) sum*=2.0;
                sum+=y0;
            }
            swap(y0,y1);
        }
        if (with_y)
            return y0*(scaled?exp(i*imag(z)):exp(z))/sum;
        Cplx k1,k2,r=y0/y1,scale=scaled?exp(i*imag(z)):1.0;
        k1=K1_in(z,scaled);
        k2=K_in(2.0,z,scaled);
        if (K_val!=nullptr) *K_val=k1;
        return scale/(z*(k2+r*k1));
    }
    Cplx K_in(Real v,const Cplx &z,bool scaled,Cplx *K_val_1,OlverData *data) {
        if (zero(z))
#ifdef CBESSEL_EXCEPT
            throw of_err;
#else
            return infty;
#endif
        if (inf(z) && isinf(v))
#ifdef CBESSEL_EXCEPT
            throw ia_err;
#else
            return NAN;
#endif
        if (inf(z))
#ifdef CBESSEL_EXCEPT
            throw uf_err;
#else
            return 0.0;
#endif
        if (isinf(v))
#ifdef CBESSEL_EXCEPT
            throw of_err;
#else
            return infty;
#endif
        if (v<0.0)
            return K_in(-v,z,scaled);
        if (real(z)<0.0) {
            Cplx Kv=NAN,Iv,si=sign1(imag(z))*M_PI*i;
            OlverData data;
#ifdef CBESSEL_EXCEPT
            try {
#endif
                Iv=I_in(v,-z,scaled,&Kv,&data)*(scaled?exp(i*imag(z)):1.0);
#ifdef CBESSEL_EXCEPT
            } catch (const underflow_error &e) { Iv=0.0; }
#endif
            if (scaled || undef(Kv))
#ifdef CBESSEL_EXCEPT
            try {
#endif
                Kv=K_in(v,-z,false,nullptr,&data)*(scaled?exp(z):1.0);
#ifdef CBESSEL_EXCEPT
            } catch (const underflow_error &e) { Kv=0.0; }
#endif
            Cplx ret=exp(-si*v)*Kv-si*Iv;
#ifdef CBESSEL_EXCEPT
            if (inf(ret)) throw of_err;
#endif
            return ret;
        }
        /* Basic case: Re(z)>=0, v>=0 */
        if (v>v_L(eps)) {
            Real theta=arg(z),s=sign1(theta);
            if (3.0*abs(theta)<M_PI) {
                Real iv=1.0/v;
                Cplx zv=z*iv,zv2=zv*zv,it2=1.0+zv2,it=sqrt(it2),zet=it-log((1.0+it)/zv);
                Cplx t=1.0/it,t2=1.0/it2,tk=pow(t2,6),res=0.0;
                for (int k=12;k-->1;)
                    res=res*iv+(k%2?-1.0:1.0)*U(k,t2)*(tk*=it);
                Cplx ret=sqrt(M_PI_2*t*iv)*exp((scaled?z:0.0)-v*zet)*(iv*res+1.0);
#ifdef CBESSEL_EXCEPT
                if (inf(ret)) throw of_err;
                if (zero(ret)) throw uf_err;
#endif
                return ret;
            }
            Cplx si=M_PI*s*i,ai,aip,C,ret;
            OlverData od;
            if (data==nullptr) data=&od;
            if (!data->is_valid)
                olver(v,z,s,*data);
            bool corr;
            int e=airy_olver(v,data->xi,s,ai,aip,corr,true,scaled);
            C=-si*exp(si*(f13-v*0.5)+(scaled?z+(corr?v*data->xi:0.0):0.0))*data->phi;
#ifdef CBESSEL_EXCEPT
            if (e==1) { if (zero(C)) throw ia_err; throw of_err; }
            if (e==2) { if (inf(C)) throw ia_err; throw uf_err; }
            if (inf(C)) throw of_err;
            if (zero(C)) throw uf_err;
#endif
            ret=C*(ai*data->S1+exp(-si*f23)*aip*pow(v,-f43)*data->S2);
#ifdef CBESSEL_EXCEPT
            if (inf(ret)) throw of_err;
            if (zero(ret)) throw uf_err;
#endif
            return ret;
        }
        Cplx k0,k1,z2=2.0/z;
        int jmax=0;
        while (v>0.5) jmax++,v--;
        Real R=abs(z),theta=arg(z);
        if (v==0.5) {
            k0=sqrt(M_PI_4*z2)*(scaled?1.0:exp(-z));
            k1=(z2*0.5+1.0)*k0;
        } else if (R<=2.0) {
            bool vz=zero(v);
            Real s=vz?1.0:M_PI*v/sin(M_PI*v),g2=1.0/tgamma(1.0+v),g1=1.0/(s*g2),gama1,gama2=(g1+g2)*0.5;
            if (vz)
                gama1=D[9];
            else if (abs(v)>0.1)
                gama1=(g1-g2)*0.5/v;
            else {
                Real v2=v*v;
                gama1=accumulate(D,D+10,0.0,[&v2](Real &a,Real d) { return a*v2+d; });
            }
            Cplx lz2=log(z2),mu=v*lz2,z2v=pow(z2,-v),z2d4=1.0/(z2*z2),scale=scaled?exp(z):1.0;
            Cplx p=0.5*scale/(g2*z2v),q=0.5*scale*z2v/g1,C=1.0;
            Cplx f=s*scale*(gama1*cosh(mu)+gama2*lz2*(vz?1.0:sinh(mu)/mu));
            Real A=0.5,a=0.25*R*R,k=1.0,kmv,kpv,ki,maxiter=MAXITER;
            k0=f,k1=p;
            do {
                ki=1.0/k,kmv=1.0/(k-v),kpv=1.0/(k+v);
                C*=z2d4*ki,A*=a*ki*kmv;
                f=(k*f+p+q)*kmv*kpv;
                p*=kmv,q*=kpv;
                k0+=C*f,k1+=C*(p-k*f);
                if (inf(k0) || inf(k1))
#ifdef CBESSEL_EXCEPT
                    throw of_err;
#else
                    return infty;
#endif
            } while (A>=eps && k++<maxiter);
#ifdef CBESSEL_EXCEPT
            if (k>maxiter) throw cvg_err;
#endif
            k1*=z2;
            if (inf(k1))
#ifdef CBESSEL_EXCEPT
                throw of_err;
#else
                return infty;
#endif
        } else {
            Real v2=v*v,A=3.0/(1.0+R),B=14.7/(28.0+R);
            Real C=2.0*M_2_SQRTPI*(abs(abs(v)-.5)<eps?M_PI*eps:cos(M_PI*v))/(eps*pow(2.0*R,0.25));
            Real M=ceil(0.485/R*pow((log(C)+R*cos(A*theta)/(1.0+0.008*R))/(2.0*cos(B*theta)),2)+1.5);
            k0=0.0,k1=eps;
            Cplx S=0.0;
            for (Real n=M;n-->1.0;swap(k0,k1)) {
                S+=k1;
                k0=(n*(2.0*(z+n)*k1-(n+1.0)*k0))/((n-0.5)*(n-0.5)-v2);
            }
            Cplx r=z+v+.5-k0/k1;
            k0=(scaled?1.0:exp(-z))*sqrt(M_PI_4*z2)*k1/(S+k1);
            k1=0.5*k0*r*z2;
        }
        if (jmax==0)
            return k0;
        for (int j=1;j<jmax;++j,swap(k0,k1))
            if (inf(k0+=(++v)*z2*k1))
#ifdef CBESSEL_EXCEPT
                throw of_err;
#else
                return infty;
#endif
        if (K_val_1!=nullptr) *K_val_1=k0;
#ifdef CBESSEL_EXCEPT
        if (zero(k1)) throw uf_err;
#endif
        return k1;
    }
    Cplx K0_in(const Cplx &z,bool scaled) {
        if (zero(z))
#ifdef CBESSEL_EXCEPT
            throw of_err;
#else
            return infty;
#endif
        if (inf(z))
#ifdef CBESSEL_EXCEPT
            throw uf_err;
#else
            return 0.0;
#endif
        if (real(z)<0.0) {
            Cplx Kv=NAN,Iv,si=sign1(imag(z))*M_PI*i;
#ifdef CBESSEL_EXCEPT
            try {
#endif
                Iv=I0_in(-z,scaled,&Kv)*(scaled?exp(i*imag(z)):1.0);
#ifdef CBESSEL_EXCEPT
            } catch (const underflow_error &e) { Iv=0.0; }
#endif
            if (scaled || undef(Kv))
#ifdef CBESSEL_EXCEPT
            try {
#endif
                Kv=K0_in(-z,false)*(scaled?exp(z):1.0);
#ifdef CBESSEL_EXCEPT
            } catch (const underflow_error &e) { Kv=0.0; }
#endif
            Cplx ret=Kv-si*Iv;
#ifdef CBESSEL_EXCEPT
            if (inf(ret)) throw of_err;
#endif
            return ret;
        }
        /* Basic case: Re(z)>=0, v>=0 */
        Cplx k0,k1,z2=2.0/z;
        Real R=abs(z),theta=arg(z);
        if (R<=2.0) {
            Cplx lz2=log(z2),z2d4=z*z*0.25,scale=scaled?exp(z):1.0,p=scale,C=1.0,f=scale*(D[9]+lz2);
            Real A=0.5,a=0.25*R*R,k=1.0,ki,maxiter=MAXITER;
            k0=f;
            do {
                ki=1.0/k;
                C*=z2d4*ki,A*=a*ki*ki;
                f=(f+(p*=ki))*ki;
                k0+=C*f;
#ifdef CBESSEL_EXCEPT
                if (inf(k0)) throw of_err;
#endif
            } while (A>=eps && k++<maxiter);
#ifdef CBESSEL_EXCEPT
            if (k>maxiter) throw cvg_err;
#endif
            return k0;
        }
        Real A=3.0/(1.0+R),B=14.7/(28.0+R),C=2.0*M_2_SQRTPI/(eps*pow(2.0*R,0.25));
        Real M=ceil(0.485/R*pow((log(C)+R*cos(A*theta)/(1.0+0.008*R))/(2.0*cos(B*theta)),2)+1.5);
        k0=0.0,k1=eps;
        Cplx S=0.0;
        for (Real n=M;n-->1.0;swap(k0,k1)) {
            S+=k1;
            k0=(n*(2.0*(z+n)*k1-(n+1.0)*k0))/((n-0.5)*(n-0.5));
        }
        return (scaled?1.0:exp(-z))*sqrt(M_PI_4*z2)*k1/(S+k1);
    }
    Cplx K1_in(const Cplx &z,bool scaled) {
        if (zero(z))
#ifdef CBESSEL_EXCEPT
            throw of_err;
#else
            return infty;
#endif
        if (inf(z))
#ifdef CBESSEL_EXCEPT
            throw uf_err;
#else
            return 0.0;
#endif
        if (real(z)<0.0) {
            Cplx Kv=NAN,Iv,si=sign1(imag(z))*M_PI*i;
#ifdef CBESSEL_EXCEPT
            try {
#endif
                Iv=I1_in(-z,scaled,&Kv)*(scaled?exp(i*imag(z)):1.0);
#ifdef CBESSEL_EXCEPT
            } catch (const underflow_error &e) { Iv=0.0; }
#endif
            if (scaled || undef(Kv))
#ifdef CBESSEL_EXCEPT
            try {
#endif
                Kv=K1_in(-z,false)*(scaled?exp(z):1.0);
#ifdef CBESSEL_EXCEPT
            } catch (const underflow_error &e) { Kv=0.0; }
#endif
            Cplx ret=-Kv-si*Iv;
#ifdef CBESSEL_EXCEPT
            if (inf(ret)) throw of_err;
#endif
            return ret;
        }
        /* Basic case: Re(z)>=0, v>=0 */
        Cplx k0,k1,z2=2.0/z;
        Real R=abs(z),theta=arg(z);
        if (R<=2.0) {
            Cplx lz2=log(z2),z2d4=z*z*0.25,scale=scaled?exp(z):1.0,p=0.5*scale,C=1.0,f=scale*(D[9]+lz2);
            Real A=0.5,a=0.25*R*R,k=1.0,ki,maxiter=MAXITER;
            k1=p;
            do {
                ki=1.0/k;
                C*=z2d4*ki,A*=a*ki*ki;
                f=(f+2.0*(p*=ki))*ki;
                k1+=C*(p-k*f);
#ifdef CBESSEL_EXCEPT
                if (inf(k1)) throw of_err;
#endif
            } while (A>=eps && k++<maxiter);
#ifdef CBESSEL_EXCEPT
            if (k>maxiter) throw cvg_err;
#endif
#ifdef CBESSEL_EXCEPT
            if (inf(k1)) throw of_err;
#endif
            return k1*z2;
        }
        Real A=3.0/(1.0+R),B=14.7/(28.0+R),C=2.0*M_2_SQRTPI/(eps*pow(2.0*R,0.25));
        Real M=ceil(0.485/R*pow((log(C)+R*cos(A*theta)/(1.0+0.008*R))/(2.0*cos(B*theta)),2)+1.5);
        k0=0.0,k1=eps;
        Cplx S=0.0;
        for (Real n=M;n-->1.0;swap(k0,k1)) {
            S+=k1;
            k0=(n*(2.0*(z+n)*k1-(n+1.0)*k0))/((n-0.5)*(n-0.5));
        }
        Cplx r=z+.5-k0/k1;
        k0=(scaled?1.0:exp(-z))*sqrt(M_PI_4*z2)*k1/(S+k1);
        k1=0.5*k0*r*z2;
        return k1;
    }

    /* Bessel functions J_v(z) and Y_v(z) */
    Cplx J(Real v,const Cplx &z,bool scaled) {
        Cplx si=sign1(imag(z))*i;
        if (v>=0.0) {
            if (zero(arg(z))) {
                if (v==0.0)
                    return j0(real(z));
                if (v==1.0)
                    return j1(real(z));
                return cyl_bessel_j(v,real(z));
            }
            if (abs(zero(arg(z))-M_PI))
                return exp(si*M_PI*v)*cyl_bessel_j(v,-real(z));
            if (v==0.0)
                return I0_in(-z*si,scaled);
            if (v==1.0)
                return si*I1_in(-z*si,scaled);
        }
        return exp(si*M_PI_2*v)*I_in(v,-z*si,scaled);
    }
    Cplx Y(Real v,const Cplx &z,bool scaled) {
        if (zero(imag(z))) {
            if (v==0.0)
                return j0(real(z));
            if (v==1.0)
                return j1(real(z));
            if (v>0.0)
                return cyl_neumann(v,real(z));
        }
        Real s=sign1(imag(z)),va=abs(v);
        Cplx si=i*s,a=exp(va*M_PI_2*si),iz=z*si,Kv=NAN,Iv;
#ifdef CBESSEL_EXCEPT
        try {
#endif
            if (va==0.0)
                Iv=I0_in(-iz,scaled,&Kv);
            else if (va==1.0)
                Iv=I1_in(-iz,scaled,&Kv);
            else Iv=I_in(va,-iz,scaled,&Kv);
#ifdef CBESSEL_EXCEPT
        } catch (const underflow_error &e) { Iv=0.0; }
#endif
        if (scaled || undef(Kv))
#ifdef CBESSEL_EXCEPT
        try
#endif
            {
            if (va==0.0)
                Kv=K0_in(-iz,false);
            else if (va==1.0)
                Kv=K1_in(-iz,false);
            else Kv=K_in(va,-iz,false);
            if (scaled)
                Kv*=exp(-abs(imag(z)));
            }
#ifdef CBESSEL_EXCEPT
        catch (const underflow_error &e) { Kv=0.0; }
#endif
        Cplx ret=si*a*Iv-M_2_PI*Kv/a;
        if (v>=0.0)
            return ret;
        int n;
        if (abs(2.0*v-(n=int(round(2.0*v))))<eps && n%2)
            return ((-n/2)%2?-1.0:1.0)*a*Iv;
        if (va==0.0)
            return ret;
        if (va==1.0)
            return -ret;
        return cos(M_PI*va)*ret+sin(M_PI*va)*a*Iv;
    }
    /* modified Bessel functions I_v(z) and K_v(z) */
    Cplx I(Real v,const Cplx &z,bool scaled) {
        if (v==0.0)
            return I0_in(z,scaled);
        if (v==1.0)
            return I1_in(z,scaled);
        return I_in(v,z,scaled);
    }
    Cplx K(Real v,const Cplx &z,bool scaled) {
        if (v==0.0)
            return K0_in(z,scaled);
        if (v==1.0)
            return K1_in(z,scaled);
        return K_in(v,z,scaled);
    }
    /* Hankel function H^(kind)_v(z) */
    inline Cplx H(Real v,const Cplx &z,int kind,bool scaled) {
#ifdef CBESSEL_EXCEPT
        if (kind<1 || kind>2)
            throw domain_error("Invalid kind");
#endif
        Real va=abs(v),s=kind==1?1.0:-1.0;
        Cplx si=i*s,a=exp(M_PI_2*va*si),iz=si*z,ret;
        if (s*arg(z)>=-M_PI_2) {
            ret=i*M_1_PI/a*K_in(va,-iz,scaled);
        } else {
            OlverData data;
            Cplx Kv=NAN,Iv;
#ifdef CBESSEL_EXCEPT
            try {
#endif
                Iv=I_in(va,iz,scaled,&Kv,&data);
#ifdef CBESSEL_EXCEPT
            } catch (const underflow_error &e) { Iv=0.0; }
#endif
            if (scaled || undef(Kv))
#ifdef CBESSEL_EXCEPT
            try {
#endif
                Kv=K_in(va,iz,false,nullptr,&data)*(scaled?exp(-iz):1.0);
#ifdef CBESSEL_EXCEPT
            } catch (const underflow_error &e) { Kv=0.0; }
#endif
            ret=i*M_1_PI*a*Kv-s*Iv/a*(scaled?exp(-si*real(z)):1.0);
        }
        return -2.0*s*(v>=0.0?ret:a*a*ret);
    }
    inline Cplx H_v0(const Cplx &z,int kind,bool scaled) {
#ifdef CBESSEL_EXCEPT
        if (kind<1 || kind>2)
            throw domain_error("Invalid kind");
#endif
        Real s=kind==1?1.0:-1.0;
        Cplx si=i*s,iz=si*z,ret;
        if (s*arg(z)>=-M_PI_2) {
            ret=i*M_1_PI*K0_in(-iz,scaled);
        } else {
            Cplx Kv=NAN,Iv;
#ifdef CBESSEL_EXCEPT
            try {
#endif
                Iv=I0_in(iz,scaled,&Kv);
#ifdef CBESSEL_EXCEPT
            } catch (const underflow_error &e) { Iv=0.0; }
#endif
            if (scaled || undef(Kv))
#ifdef CBESSEL_EXCEPT
            try {
#endif
                Kv=K0_in(iz,false)*(scaled?exp(-iz):1.0);
#ifdef CBESSEL_EXCEPT
            } catch (const underflow_error &e) { Kv=0.0; }
#endif
            ret=i*M_1_PI*Kv-s*Iv*(scaled?exp(-si*real(z)):1.0);
        }
        return -2.0*s*ret;
    }
    inline Cplx H_v1(const Cplx &z,int kind,bool scaled) {
#ifdef CBESSEL_EXCEPT
        if (kind<1 || kind>2)
            throw domain_error("Invalid kind");
#endif
        Real s=kind==1?1.0:-1.0;
        Cplx si=i*s,iz=si*z,ret;
        if (s*arg(z)>=-M_PI_2) {
            ret=s*M_1_PI*K1_in(-iz,scaled);
        } else {
            Cplx Kv=NAN,Iv;
#ifdef CBESSEL_EXCEPT
            try {
#endif
                Iv=I1_in(iz,scaled,&Kv);
#ifdef CBESSEL_EXCEPT
            } catch (const underflow_error &e) { Iv=0.0; }
#endif
            if (scaled || undef(Kv))
#ifdef CBESSEL_EXCEPT
            try {
#endif
                Kv=K1_in(iz,false)*(scaled?exp(-iz):1.0);
#ifdef CBESSEL_EXCEPT
            } catch (const underflow_error &e) { Kv=0.0; }
#endif
            ret=-s*M_1_PI*Kv+i*Iv*(scaled?exp(-si*real(z)):1.0);
        }
        return -2.0*s*ret;
    }
    /* Hankel functions */
    Cplx H1(Real v,const Cplx &z,bool scaled) {
        if (v==0.0) {
            if (zero(imag(z)))
                return Cplx(j0(real(z)),y0(real(z)));
            return H_v0(z,1,scaled);
        }
        if (v==1.0) {
            if (zero(imag(z)))
                return Cplx(j1(real(z)),y1(real(z)));
            return H_v1(z,1,scaled);
        }
        return H(v,z,1,scaled);
    }
    Cplx H2(Real v,const Cplx &z,bool scaled) {
        if (v==0.0) {
            if (zero(imag(z)))
                return Cplx(j0(real(z)),-y0(real(z)));
            return H_v0(z,2,scaled);
        }
        if (v==1.0) {
            if (zero(imag(z)))
                return Cplx(j1(real(z)),-y1(real(z)));
            return H_v1(z,2,scaled);
        }
        return H(v,z,2,scaled);
    }
    Cplx H1_0_i(const Cplx &z,bool scaled) {
        if (zero(imag(z)))
            return Cplx(-y0(real(z)),j0(real(z)));
        return i*H_v0(z,1,scaled);
    }
    Cplx H1_1_i(const Cplx &z,bool scaled) {
        if (zero(imag(z)))
            return Cplx(-y1(real(z)),j1(real(z)));
        return i*H_v1(z,1,scaled);
    }

    /* n-th derivative of Bessel function f_v(z) */
    Cplx bessel_derive(Real v,const Cplx &z,int n,Cplx (*f)(Real,const Cplx&,bool),bool alt) {
        Cplx ret=0.0,t;
        int C=1,k=0;
        for (;k<=n;++k) {
            try { t=f(v-n+2*k,z,false); }
            catch (const underflow_error &e) { t=0.0; }
            ret+=(alt&&k%2?-1.0:1.0)*C*t;
            C=(C*(n-k))/(k+1);
        }
        if (zero(ret))
#ifdef CBESSEL_EXCEPT
            throw uf_err;
#else
            return 0.0;
#endif
        ret*=pow(2.0,-n);
        return ret;
    }
    Cplx Ip(Real v,const Cplx &z,int n) {
        return bessel_derive(v,z,n,&I,false);
    }
    Cplx Jp(Real v,const Cplx &z,int n) {
        return bessel_derive(v,z,n,&J,true);
    }
    Cplx Kp(Real v,const Cplx &z,int n) {
        return (n%2?-1.0:1.0)*bessel_derive(v,z,n,&K,false);
    }
    Cplx Yp(Real v,const Cplx &z,int n) {
        return bessel_derive(v,z,n,&Y,true);
    }
    Cplx H1p(Real v,const Cplx &z,int n) {
        return bessel_derive(v,z,n,&H1,true);
    }
    Cplx H2p(Real v,const Cplx& z,int n) {
        return bessel_derive(v,z,n,&H2,true);
    }

    /* Compute f and g (resp. f' and g' if p=true) for Airy power series.
     * MODE is 1 for f,g, 2 for f',g', and 3 for both f,g and f',g'. */
    void airy_series(const Cplx &z,int mode,Cplx &f,Cplx &g,Cplx &fp,Cplx &gp) {
        Cplx z3=pow(z,3),zp=1.0;
        Real z3a=1.0/abs(z3),tol=eps/(mode>1?1.07:1.05);
        f=g=fp=gp=1.0;
        const Real *fc=&fg_coef[0],*fpc=&fg_coef[14],*gc=&fg_coef[7],*gpc=&fg_coef[21];
        bool np=mode%2,p=mode>1;
        for (int j=0;j<7&&(*fc>=tol||*gc>=tol);++j,++fc,++gc,++fpc,++gpc) {
            tol*=z3a,zp*=z3;
            if (np) f+=*fc*zp,g+=*gc*zp;
            if (p) fp+=*fpc*zp,gp+=*gpc*zp;
        }
    }
    /* Airy functions and their first derivatives */
    Cplx Ai(const Cplx &z,bool scaled) {
        if (norm(z)<=1) {
            Cplx f,g,fp,gp;
            airy_series(z,1,f,g,fp,gp);
            return (scaled?exp(f23*pow(z,f32)):1.0)*(airy_C1*f-airy_C2*z*g);
        }
        Real a=arg(z);
        Cplx si=sign1(a)*i,sz=sqrt(z),w=f23*sz*z,Kv=NAN,Iv;
        if (abs(a)<=M_PI*f23)
            return M_1_PI*sqrt_1_3*sz*K_in(f13,w,scaled);
#ifdef CBESSEL_EXCEPT
        try {
#endif
            Iv=I_in(f13,-w,scaled,&Kv)*(scaled?exp(i*imag(w)):1.0);
#ifdef CBESSEL_EXCEPT
        } catch (const underflow_error &e) { Iv=0.0; }
#endif
        if (scaled || undef(Kv))
#ifdef CBESSEL_EXCEPT
        try {
#endif
            Kv=K_in(f13,-w,false);
#ifdef CBESSEL_EXCEPT
        } catch (const underflow_error &e) { Kv=0.0; }
#endif
        return sqrt_1_3*sz*(M_1_PI*Kv*exp((scaled?w:0.0)-si*M_PI*f13)-si*Iv);
    }
    Cplx Aip(const Cplx &z,bool scaled) {
        if (norm(z)<=1) {
            Cplx f,g,fp,gp;
            airy_series(z,2,f,g,fp,gp);
            return (scaled?exp(f23*pow(z,f32)):1.0)*(z*z*airy_C1*fp*0.5-airy_C2*gp);
        }
        Real a=arg(z),b=M_PI*f23;
        Cplx is=sign1(a)*i,w=f23*pow(z,1.5),Kv=NAN,Iv;
        if (abs(a)<=b)
            return -M_1_PI*z*sqrt_1_3*K_in(f23,w,scaled);
#ifdef CBESSEL_EXCEPT
        try {
#endif
            Iv=I_in(f23,-w,scaled,&Kv)*(scaled?exp(i*imag(w)):1.0);
#ifdef CBESSEL_EXCEPT
        } catch (const underflow_error &e) { Iv=0.0; }
#endif
        if (scaled || undef(Kv))
#ifdef CBESSEL_EXCEPT
        try {
#endif
            Kv=K_in(f23,-w,false);
#ifdef CBESSEL_EXCEPT
        } catch (const underflow_error &e) { Kv=0.0; }
#endif
        return z*sqrt_1_3*(is*Iv-M_1_PI*Kv*exp((scaled?w:0.0)-is*b));
    }
    Cplx Bi(const Cplx &z,bool scaled) {
        if (norm(z)<=1) {
            Cplx f,g,fp,gp;
            airy_series(z,1,f,g,fp,gp);
            return (scaled?exp(-f23*abs(real(pow(z,f32)))):1.0)
                *(airy_C1*f+airy_C2*z*g)/sqrt_1_3;
        }
        Real a=arg(z),s=sign1(a),b=M_PI*f23;
        Cplx is=s*i,sz=sqrt(z),w=f23*z*sz,Kv=NAN,Iv,h1,h2;
        if (abs(a)<=b) {
            int k=int(round((s+1.0)*0.5));
            Real t=sign1(real(w));
#ifdef CBESSEL_EXCEPT
            try {
#endif
                h1=H(f13,-is*w,2-k,scaled && t>0.0)
                    *exp((scaled?(t>0.0?i*imag(w):-abs(real(w))):0.0)+M_PI*is*f16);
#ifdef CBESSEL_EXCEPT
            } catch (const underflow_error &e) { h1=0.0; }
            try {
#endif
                h2=H(f13,-is*w,1+k,scaled && t<0.0)
                    *exp((scaled?(t<0.0?-i*imag(w):-abs(real(w))):0.0)-M_PI*is*f16);
#ifdef CBESSEL_EXCEPT
            } catch (const underflow_error &e) { h2=0.0; }
#endif
            return sqrt_1_3*sz*(h1+0.5*h2);
        }
#ifdef CBESSEL_EXCEPT
        try {
#endif
            Iv=I_in(f13,-w,scaled,&Kv);
#ifdef CBESSEL_EXCEPT
        } catch (const underflow_error &e) { Iv=0.0; }
#endif
        if (scaled || undef(Kv))
#ifdef CBESSEL_EXCEPT
        try {
#endif
            Kv=K_in(f13,-w,false);
#ifdef CBESSEL_EXCEPT
        } catch (const underflow_error &e) { Kv=0.0; }
#endif
        return sz*(Iv*sqrt_1_3+M_1_PI*exp((scaled?real(w):0.0)-is*M_PI*f13)*Kv);
    }
    Cplx Bip(const Cplx &z,bool scaled) {
        if (norm(z)<=1) {
            Cplx f,g,fp,gp;
            airy_series(z,2,f,g,fp,gp);
            return (scaled?exp(-f23*abs(real(pow(z,f32)))):1.0)
                *(z*z*airy_C1*fp*0.5+airy_C2*gp)/sqrt_1_3;
        }
        Real a=arg(z),s=sign1(a),b=M_PI*f23;
        Cplx is=s*i,w=f23*pow(z,1.5),Kv=NAN,Iv,h1,h2;
        if (abs(a)<=b) {
            int k=int(round((s+1.0)*0.5));
            Real t=sign1(real(w));
#ifdef CBESSEL_EXCEPT
            try {
#endif
                h1=H(f23,-is*w,2-k,scaled && t>0.0)
                    *exp((scaled?(t>0.0?i*imag(w):-abs(real(w))):0.0)+is*M_PI*f13);
#ifdef CBESSEL_EXCEPT
            } catch (const underflow_error &e) { h1=0.0; }
            try {
#endif
                h2=H(f23,-is*w,1+k,scaled && t<0.0)
                    *exp((scaled?(t<0.0?-i*imag(w):-abs(real(w))):0.0)-is*M_PI*f13);
#ifdef CBESSEL_EXCEPT
            } catch (const underflow_error &e) { h2=0.0; }
#endif
            return z*sqrt_1_3*(h1-0.5*h2);
        }
#ifdef CBESSEL_EXCEPT
        try {
#endif
            Iv=I_in(f23,-w,scaled,&Kv);
#ifdef CBESSEL_EXCEPT
        } catch (const underflow_error &e) { Iv=0.0; }
#endif
        if (scaled || undef(Kv))
#ifdef CBESSEL_EXCEPT
        try {
#endif
            Kv=K_in(f23,-w,false);
#ifdef CBESSEL_EXCEPT
        } catch (const underflow_error &e) { Kv=0.0; }
#endif
        return z*(M_1_PI*exp((scaled?real(w):0.0)-is*M_PI*f23)*Kv-Iv*sqrt_1_3);
    }
    /* Compute both Ai and Aip for Olver expansions.
     * Return 0 if AI and AIP are both normal, 1 if
     * one of them is infinite and 2 if both are zero. */
    int airy_olver(Real v,const Cplx &xi,Real s,Cplx &ai,Cplx &aip,bool &corr,bool rot,bool scaled) {
        Real b=M_PI*f23,t=sign1(imag(xi));
        Cplx alpha=s*t>=0.0?pow(v/f23*xi,f23):pow(v/f23*abs(xi),f23)*exp((arg(xi)-t*2.0*M_PI)*f23*i);
        Cplx beta=alpha*(rot?exp(-s*b*i):1.0);
        corr=false;
        if (abs(alpha)<=1) {
            Cplx f,g,fp,gp;
            airy_series(beta,3,f,g,fp,gp);
            ai=airy_C1*f-airy_C2*beta*g;
            aip=beta*beta*airy_C1*fp*0.5-airy_C2*gp;
        } else
#ifdef CBESSEL_EXCEPT
            try
#endif
        {
            corr=true;
            Real a=arg(beta),sa=sign1(a);
            Cplx is=sa*i,sz=sqrt(beta*f13),w=(rot?-v:v)*xi;
            if (abs(a)<=b) {
#ifdef CBESSEL_EXCEPT
                try {
#endif
                    ai=M_1_PI*sz*K(f13,w,scaled);
#ifdef CBESSEL_EXCEPT
                } catch (const underflow_error &e) { ai=0.0; }
                try {
#endif
                    aip=-M_1_PI*beta*sqrt_1_3*K(f23,w,scaled);
#ifdef CBESSEL_EXCEPT
                } catch (const underflow_error &e) { aip=0.0; }
#endif
            } else {
                Cplx sf=scaled?exp(i*imag(w)):1.0;
#ifdef CBESSEL_EXCEPT
                try {
#endif
                    ai=sz*(M_1_PI*K(f13,-w)*exp((scaled?w:0.0)-is*M_PI*f13)-is*I(f13,-w,scaled)*sf);
#ifdef CBESSEL_EXCEPT
                } catch (const underflow_error &e) { ai=0.0; }
                try {
#endif
                    aip=beta*sqrt_1_3*(is*I(f23,-w,scaled)*sf-M_1_PI*K(f23,-w)*exp((scaled?w:0.0)-is*b));
#ifdef CBESSEL_EXCEPT
                } catch (const underflow_error &e) { aip=0.0; }
#endif
            }
#ifdef CBESSEL_EXCEPT
        } catch (const overflow_error &e) {
            return 1;
#endif
        }
#ifdef CBESSEL_EXCEPT
        if (zero(ai) && zero(aip))
            return 2;
#endif
        return 0;
    }

}

